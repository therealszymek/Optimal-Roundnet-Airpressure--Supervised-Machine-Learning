# -*- coding: utf-8 -*-
"""Optimal Roundnet Airpressure: Supervised Machine Learning

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1W7ZPofS_2KlPWTeLeHcFddhiAnY9Cy_p
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import statsmodels.api as sm
from sklearn.metrics import r2_score

def organize_csv_rows(file_path):
  # Read the CSV file
    data = pd.read_csv(file_path)

  # Sort the DataFrame based on the first column
    sorted_data = data.sort_values(by=data.columns[0])

  # Write the sorted data back to the CSV file
    sorted_data.to_csv(file_path, index=False)

def analyze_roundnet_data(data):
  # method 1 calculates and returns the 'mean_shoulder_height' variable:
    def calculate_mean_shoulder_height(data):
        return np.mean(data['Player_Shoulder_Height_[cm]']) - 20.32

  # method 2 calculates and returns the 'safety_distance' variable:
    def calculate_safety_distance(mean_shoulder_height):
        return abs((mean_shoulder_height + 50.8) / 2)

  # method 3 calculates and returns the 'x' and 'y' axis variables:
    def preprocess_data(data, mean_shoulder_height, safety_distance):
        x = data['Air_Pressure_[PSI]']
        y = abs(data['Rebound_Height_[cm]'] - safety_distance)
        return x, y

  # method 4 splits data to avoid overfitting:
    def split_data(x, y):
        percentage_data = int(0.80 * x.shape[0])
        train_x = x[:percentage_data]
        train_y = y[:percentage_data]
        test_x = x[percentage_data:]
        test_y = y[percentage_data:]
        return train_x, train_y, test_x, test_y

  # method 5 follows BIC to determine optimal power for polynomial regression:
    def find_optimal_power(x, y, max_power):
        best_bic = np.inf
        optimal_power = None

        for power in range(1, max_power + 1):
            x_power = np.column_stack([x ** i for i in range(1, power + 1)])
            bic = sm.OLS(y, sm.add_constant(x_power)).fit().bic
            if bic < best_bic:
                best_bic = bic
                optimal_power = power

        return optimal_power

  # method 6 creates a model based on split data values:
    def create_model(train_x, train_y, optimal_power):
        poly_model = np.poly1d(np.polyfit(train_x, train_y, optimal_power))
        return poly_model

  # method 7 calculates r2 value to observe how well regression model explains observed data:
    def calculate_r2(train_y, predicted_y):
        return r2_score(train_y, predicted_y)

  # method 8 finds derivative of polynomial regression model, then finds its roots (critical points) to find global minima:
    def find_critical_points(poly_model):
        poly_model_deriv = poly_model.deriv()
        roots = np.roots(poly_model_deriv.coef)
        filtered_roots = [root for root in roots if np.isreal(root) and 0 < root < 1]
        minima = poly_model(filtered_roots)
        global_min_index = np.argmin(minima)
        x_global_min = filtered_roots[global_min_index]
        return x_global_min

  # method 9 returns predicted value from 'find_critical_points(poly_model)' in a sliced string format:
    def predict_optimal_air_pressure(x_global_min):
        predicted_value = str(x_global_min)[1:6]
        return predicted_value

  # 'mean_shoulder_height' and 'safety_distance' are defined via methods 1 and 2:
    mean_shoulder_height = calculate_mean_shoulder_height(data)
    safety_distance = calculate_safety_distance(mean_shoulder_height)

  # 'x' and 'y' are defined via method 3:
    x, y = preprocess_data(data, mean_shoulder_height, safety_distance)

  # data is split via method 4:
    train_x, train_y, test_x, test_y = split_data(x, y)

  # optimal power for polynomial regression is defined via method 5:
    max_power = 10
    optimal_power = find_optimal_power(train_x, train_y, max_power)

  # polynomial regression function is defined via method 6:
    poly_model = create_model(train_x, train_y, optimal_power)

  # r2 value is calculated via method 7:
    r2 = calculate_r2(train_y, poly_model(train_x))

  # critical points calculated via method 8:
    x_global_min = find_critical_points(poly_model)

  # predicted value of optimized air pressure based global minima x-value via method 9:
    predicted_value = predict_optimal_air_pressure(x_global_min)

  # model is plotted on a graph image:
    poly_line = np.linspace(0, 1, 100)
    plt.scatter(train_x, train_y)
    plt.plot(poly_line, poly_model(poly_line))
    plt.xlim(0, 1)
    plt.ylim(0, abs(mean_shoulder_height - safety_distance))
    plt.show()

  # print results:
    print('\033[1mMean shoulder height:\033[0m', mean_shoulder_height, 'cm')
    print('\n\033[1mPoint of safety:\033[0m', safety_distance, 'cm')
    print('\n\033[1mOptimal power:\033[0m', optimal_power)
    print('\n\033[1mPolynomial Model:\033[0m\n', poly_model)
    print('\n\033[1mr^2 value:\033[0m', r2)
    print('\n\033[1mPredicted optimal air pressure:\033[0m', predicted_value, 'PSI')

data = pd.read_csv('roundnetdata.csv')
organize_csv_rows('roundnetdata.csv')
print(data)
analyze_roundnet_data(data)
